---
layout: post
title:  Linux 系统
category: other
keywords: [improvement,android,java,os]
---

补一波 OS 基础知识:

Unix 的输出哲学:  极简化,文本化,面向流,设备无关格式    

###  Linux

#### 万物皆文本

大道即简,万物皆文本   

文本化带来的通用化,对使用者友好,配置文本化,甚至硬件也文本化,只需要看文本遍可知道所有硬件的挂载状态,硬件的配置,硬件特性修改也只需要操作文本便可以完成; 

程序间的组合沟通,同样适用通用文本,文本只需要保证编解码一致性则可以保证程序间的独立性,下游不关心上游,上游不关注下游,彼此独立;

文本的解析可能带来一些性能方面的影响,但当无法用数据证明文本的解析对系统造成了影响成为性能瓶颈时,对其的改变便是过早优化 -- 用数据说话,而不是猜测 -- From 调试九法   

文本传输带来的空间尺度问题 - 在高效的数据压缩策略下,文本传输与二进制传输几乎无差别,但数据压缩的压缩算法同样对性能可能造成影响;

Linux 丰富的以文本形式存在的脚本,启动脚本,配置脚本,执行脚本,脚本作为胶水语言,用于弥补设计上的缺陷,事实上无论是自顶向下的设计还是自底向上的设计都存在其对应的缺陷;自顶向下的问题在于可能存在无法实现的下层,自底向上的缺陷在于存在过多与最终目的无关的设计与实现;随之衍生出"正确的自顶向下"以及依靠胶合层实现的双管齐下,上下层独立;

#### Linux 

Linux 有多重分离的发行版本,我常用的 CentOS,Ubuntu,RedHat..., 各版本甚至对于同一功能机制的实现都各不一样,如防火墙控制策略

Linux 中的丰富的 IPC 机制为 Linux 中机制与策略实现上下层分离提供了良好的基础支持: 信号,管道, IO 重定向,共享内存,Socket 等..

Linux 还有用庞杂的配置文件,在新人以及专家手中 Linux 甚至不是同一个系统,当然这也是 Linux 自由的一个体现;

#### Unix 哲学 

* 每个程序做好一件事 - 简洁  

* 你无法判断程序会在什么地方耗时,瓶颈也经常出现在意想不到的地方,在没有证实时不要随意修改代码;在没有对代码进行估量,找到最耗时的地方前,不要去优化速度,速度与性能的优化要基于实际数据,优化是可量化的;

* 清晰的设计胜于技巧的设计,设计应该透明可见以便于后期的调试;           
* 透明与简洁带来健壮性;            
* 策略与机制分离:  MVC

### fork   

进程与线程

线程通信

进程 IPC   

Linux 的线程实现:NPTL - 原生 POSIX线程库,内核创建与回收线程,线程与内核线程调度实体 1:1;





### mmap    


### epoll   


### VFS   


### 并发  









---  

Quote :

<Unix&Linux 大学教程>

<深入理解计算机系统>

<Linux 就是这个范儿>