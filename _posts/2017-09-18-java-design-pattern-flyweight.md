---
layout: post
title:  Java模式-享元模式
category: java
keywords: [improvement,design,java,]
---

Android  Message的构建(Message.Obtain())使用享元模式.

享元模式的核心是分离与共享,分离变与不变,抽取不变共享,将一个对象的状态分离为不变的内部状态,以及变化的外部状态,进而共享不变,注入外部状态组合实现共享对象;

此外内外状态之间分离后的独立性也是非常重要的,外部状态的存在应该不影响内部状态,否则分离就是不成功的.

享元模式的核心在于分离外部状态,内外独立,而独立似乎又好像和高内聚有点冲突,同时分离外部状态事实上会造成逻辑的复杂化,所以还是前辈说得好,学习规则但不生搬硬套规则.

### 享元模式是什么?

> 运用对象共享有效的支持大量细粒度对象

通过抽象出细粒度对象,因为对象的粒度细,进而可以很便捷的实现对象的缓存与共享;(一旦缓存对象的属性状态经常变更,就需要同步修改缓存对象的状态,这时缓存对象会导致极为复杂的更新逻辑,所以缓存与否需要特殊情况特殊看待,不能生搬硬套).

### 享元模式解决什么问题?  

大量重复对象的频繁创建,导致资源被迅速消耗,进而引起 GC 导致系统变慢甚至 OOM.而享元模式则通过分离内部不变,与独立的外部环境,通过内部不变元素的构建工厂获取内部享元对象,进而使得内部同一类对象可以被复用,减少重复对象创建;

### 享元模式如何使用?

享元模式的核心UML 非常简单,其核心就是享元工厂的构建,构建享元工厂复用享元对象其前提就在处理好内外部状态的分离;

Android 源码分析:

我们知道UI不可以在非其创建线程中被更新,而 UI 通常在主线程中被创建,就导致 UI 需要在主线程中更新;事实上如果我们在子线程中利用 Windowmanager 处理也是能够添加 View 处理 UI 信息的;而在更新 UI 我们大量使用 Handler发送 Message,Message 的构建就是利用享元模式处理;










---

Quote:

<设计模式>

<研磨设计模式>

<Android 源码设计模式>

[图解享元模式](http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html)
    

