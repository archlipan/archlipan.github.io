---
layout: post
title:   读" 程序是怎样跑起来的"
category: others
keywords: [improvement,study]
---

## 程序是怎样跑起来的?    

### CPU  

寄存器 / 控制器 / 运算器 /时钟


CPU 寄存器: 负责保存程序指令以及数据等处理对象      

汇编语言与机器语言,汇编语言本质是一种机器语言助记符.
所有语言最终都会编译处理生成 CPU 能够直接解释执行的机器语言存在.

根据寄存器中所存储数据内容的不同,将寄存器分为不同的类型,寄存器中存储的可以是数据也可以是指令.    

存储指令的是指令寄存器.

存储的数据的分为运算数值以及表示地址的数值.  

程序计数器也是一种寄存器,存储下一条执行指令所在的内存地址.

标志寄存器存储运算处理之后的 CPU 状态.条件分支在判断时将条件的比较结果存储在标志寄存器中,根据标志寄存器结果进行跳转. CPU 的比较本质是利用减法运算.

* 函数的调用 

call 指令与 return 指令. 
函数执行时执行的是 call 指令而非简单的跳转指令,call 指令将函数执行下一步的指令地址存放在函数调用栈主存中,当函数执行完毕 return 函数执行下一步的指令地址到程序计数器, 程序继续恢复原有流程执行.

* 数组的实现

基址寄存器 与 变址寄存器 组合构建连续内存地址.   

* CPU指令类别  

>  数据转送指令 : 数据读写          
>  运算指令        
>  跳转指令    : 指令跳转,顺序/条件逻辑        
>  call/return 指令: 函数的调用/返回调用前地址

### 二进制数  

计算机内部一切都是0/1二进制表示.

字节: 1bit: 8  
 
二进制数转换.

补数的处理: 二进制的最高位通常作为符号位处理,用于标识数值的正负.补数 = 数位取反 + 1  

**将二进制数取反 + 1 之后 再与原来的数相加结果为0**. 结对记忆 1/ -1 的二进制表示. -1 不是 10000001 而是 00000001 的补码表示, 11111111, 二者相加, 位溢出忽略, 结果为0.

计算机中的减法实际是利用加法器做运算. 1 -1 实际是 1 + (-1).

### 浮点数不精确表示  

正如同 1/3 无法用十进制精确表示, 二进制中很多小数也无法精确表示. 

十进制数表示 = 数值 * 位权. 

纸面上的二进制表示与计算机内部的二进制表示之间存在差异.

小数的浮点数表示.   

正确理解浮点数与定点数.  定点数表示小数点位置固定,而浮点数则表示小数点位置表示与实际小数点位置不同. 如科学计数法之类的表示形式. 


浮点数表示:  符号位/尾数/基数/指数位  

由于数值表现形式的多样化,如果没有统一的形式,那么计算机实现时需要兼容的情况就会变多,因而由标准化规定: 

* 二进制小数,小数点前面的值固定为1.        

浮点数指数的 EXCESS 表示.

有时为了节约表示位数,可以将二进制转换为16进制表示,一位16进制可以转换为4位2进制表示.

本章节核心在于说明: 计算机浮点数计算的不精确性以及原因.
### 内存  

内存的物理机制: 内存 IC. 

内存 IC 读写数据.通过地址引脚指定地址,同时通过数据引脚指定数据,接好对应电极位,与 WR 位.即可完成输入写入.

WR/RD 被称之为控制信号.   

内存逻辑模型: 地址值递增的层序模型.(楼房)

回忆数据类型的含义: 占据内存区域的大小以及存储在该内存区域的数据类型.   
指针与指针类型: 指针是一种变量,变量中存储了内存地址.而指针类型为何需要? 指针类型用来标识从指针变量对应的该内存地址中读取的数据字节数量.  

```  
short * 类型的指针,2个字节  16位.

```

数据结构: 数组/链表/二叉树/栈/队列  


### 磁盘  

程序存储在磁盘中,但运行时需要先从磁盘加载到内存中,进而被 CPU由程序计数器指定内存地址执行.

磁盘缓存机制: 磁盘中的常用数据缓存到内存中.  

虚拟内存机制: 磁盘内容与内存空间的 swap 机制.windows 程序分页机制,将程序分页切分,以页为单位进行 swap 空间置换.
PageIn / PageOut 
如何节约内存编写程序? 

DLL 公有动态链接库,被多程序共有,节约加载内存.   
DLL 模块的更新机制,无需更新 exe 可直接更新 dll 独立文件.  

std_call 机制,栈清理机制. 在函数调用前加上 std_call ,可以将栈清理移到被调用函数中处理.一旦被调用函数是反复调用的,那么整体的程序会小很多.而默认情况下栈清理机制会附加在调用函数一方,如果一个函数被反复调用,栈清理这一处理就会被反复进行.

磁盘的物理结构: 扇区. windows 对于磁盘的逻辑读取是采用了簇为单位, 簇代表扇区的整数倍, 根据磁盘容量不同,可以是1簇为1扇区也可以是1簇多扇区.

windows 中磁盘的数据保存也以簇为单位.设置合理的簇单位可以提高磁盘的访问使用效率,同时也会带来一定程度的空间浪费.


### 源文件到可执行文件  

CPU 执行 NativeCode . 人类编写高级语言.高级语言构成的源代码文件通过编译转换生成 NativeCode.

本地代码与 Cpu 类型直接关联. x86与 x64位的 CPU 所运行的本地代码有差异,这些在编译器上存在直接体现.
利用交叉编译则可以生成其他平台的机器码. 

编译器的要素: 什么语言? 什么 CPU? 什么运行环境?   如: C 语言, x86系列, Windows 编译器. 

编译只能生成机器码,而无法得到可执行exe 文件.而生成 exe 文件的处理过程实际是链接,由链接器工具指定对应的目标文件集合共同构建产生.

库文件:  将多个目标文件集中到一个文件中的形式.
标准函数: 不是通过源代码形式提供,而是通过库文件形式集成在编译器中统一提供的,内置在编译器中简化链接过程.

DLL: 动态链接库,运行时动态加载,并与程序结合. 如果程序中没有导入所对应的 dll 文件,可以在运行时通过 loadLibrary 动态导入.

静态链接库: 存储着目标文件实体,直接与其他目标文件结合构建 exe,所相关的静态链接库都被被合成进入 exe 文件中.

动态与静态的差别: 核心在于链接过程的动态与静态.

exe 文件中为变量与函数分配虚拟地址,而程序运行时进行地址转换,转换层实际地址.链接器为 exe 文件添加地址转换过程的必要信息,称之为再配置信息.

[静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)

### 了解程序的实际构成

汇编语言: 汇编语言借助助记符来表示本地代码,汇编语言属于低级语言,贴近本地代码.借助汇编语言来了解程序本质.

汇编码与本地代码属于同一级别,是一一对应的,因而本地代码可以反汇编成为汇编码,汇编码也能够汇编转换成为本地码.

汇编码 = 操作码 & 伪指令. 

伪指令: 将程序的构造与汇编方法指示给汇编器,用于汇编码与本地代码的转换.  

指令: 汇编语言中一行表示一个 CPU 指令.指令 = 操作码 & 操作数. 其中操作数代表指令对象的内存地址以及寄存器(CPU 内部存储区域). 

汇编语言是针对 cpu 的指令,能够使用何种操作码是由 cpu 规格定义的.