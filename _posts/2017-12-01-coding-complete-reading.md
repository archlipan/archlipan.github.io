---
layout: post
title:  Code Complete 精读
category: java
keywords: [improvement,coding]
---

### 2 隐喻

比喻与类比是非常重要的表达方式,软件领域中各种形象的隐喻描述各种特定现象; 如: Bug ,不理解的东西结合类比可以产生更加深刻的理解,这种做法也称为建模;

随着科学的发展,一系列不太合适的隐喻逐渐被更好的隐喻替代;

隐喻的启示性非常重要,有方向指引作用,但不合适的隐喻会产生迷惑性;

算法的明确性与启示的模糊性,启示只有大方向,启发指引着如何去寻找有效信息;

善用隐喻对于编程的理解会更好,有助于问题抽象化,概念化;

软件开发的一些隐喻:  
* 写作         
* 培植系统: 耕作          
* 生长: 增量式,从骨架到血肉 => 从增量式开发到演进式交付到敏捷编程之类核心思想   
* 从生长到建造: 暗含了软件构建过程中的诸多阶段,建造计划,准备,设计,执行...根据要建造目标的规模其建造设计过程复杂度指数式增长;简单的建造试错成本低,复杂的建造几乎不允许出错;

**技术不是限定构建实践的规矩与框架,而只是分析工具,编程的知识学习得越多,工具箱中(脑中)的工具越多,在具体实践时应该要知道何时使用何种工具,以及如何正确的使用这些工具,并不存在一个能适用于所有的工具,因地制宜的选择正确的工具并有效编程尤其重要**

工具箱隐喻,各种语言各种技术都只是工具箱中的一个工具而已,具体问题具体分析,不要被自己熟悉的工具所限定 - 合适的时候拿来就用;

### 4 关键的构建决策  

好的符号系统让大脑从非必要工作中解脱,聚焦于更核心的工作,编程语言的选择从多个方面影响生产率与代码质量;

**你思考的能力取决于你是否知道表达该思想的词汇**

编程约定: 复杂程序中的架构指导方针,各个具体部件能反映整体架构的内涵,整体与局部之间充斥着各类风格将导致系统混乱而又邋遢,不要让自己的系统成为一幅"拼接图",到处充斥着补丁;

看清所处在技术浪潮中的位置;

**编程工具不应该决定你的编程思路;"在一种语言上编程"与"深入一种语言编程"的思想对比:在一种语言上编程的程序员思想限定于语言支持的那些构建,而深入一种语言编程者首先想清楚要表达的思想是什么,然后决定如何使用特定语言提供的工具来表达这些思想**- 先确定思想,再选择语言去表达思想,如果你所使用的语言缺乏相应的特性,那就应该自己定义约束,编码规定,标准去弥补他;  => 深入一种语言编程的思想非常重要,时刻提醒自己所采用的编程实践是对所使用编程语言的正确响应,还是受编程语言的控制,切勿被语言支配,被工具支配


### 6 类

**以所用语言编程,但思路不受其限制**

ADT:           
先考虑 ADT 而后再考虑类是深入一种语言编程的优秀实践;

接口:           
好的接口是高质量类构建最重要的核心,通过借口来展示合理的抽象,并将细节隐藏在抽象背后;抽象提供以简化形式看待复杂操作的能力,而接口则为隐藏在背后的具体实现提供了一种抽象;

接口与抽象类相比是一种自上而下的抽象,定义了子程序工作的目标,接口中每个子程序(抽象函数)都朝着这个目标工作;

类接口抽象层次的一致性; **在考虑类时始终将类看作是 ADT 的实现机制,每个类应该有且仅实现一个 ADT;**继承在某种程度上是 is 关系的提现,如果类间关系没有 is, 则可能造成类间关系混乱;

真实理解类所实现的抽象,究竟是对谁进行的提炼与抽象;

慎重修改与扩展,谨防破坏接口的抽象;随着代码的腐朽一些接口可能逐渐变为零散功能的大杂烩;

关注接口的抽象层次有助于理解类的设计,时刻反省这个类是否表现为 **一致的抽象**,每当添加接口中的子程序时,就应该检查这个子程序是否与接口抽象一致性;

封装:            
抽象通过构建让你忽略细节的模型管理系统复杂度,而封装则屏蔽细节;抽象与封装是双子星,要么同时出现,要么都不出现;封装性一旦破坏,抽象能力通常也会开始遭殃;

类的访问性控制;           
尽可能少公开暴露成员属性;       

保持可读性- 代码阅读的次数要比编写次数多得多,让代码保持可读性尤为重要;

控制子程序的公开与否仅仅由接口的抽象一致性决定;   

类的使用者的假定条件不应过多; 

语义上破坏封装性,体现为整体逻辑混乱,代码的调用不应该依赖于类的具体实现;

针对接口编程:**一旦开始通过查看类的内部实现才能逐步了解类的使用方式,就开始不是针对接口编程,而是透过接口而直接通过的内部实现来编程**

注意存在的类间过于紧密的耦合关系;        

设计与实现:     
* 组合优于继承            
* 警惕超过7个数据成员的类=> 通常人类做其他事情时能记忆的离散项目数量是 7 +/- 2;过多的数据成员,需要分解;

继承要么被配合详细的说明使用,要么就不使用,不使用继承的类最好明确标注;(final)   
只继承需要继承的;    
不要覆盖不可覆盖的成员;(java private 覆盖) ;
利用空实现覆盖某些行为,是值得特殊考究的方案,是不是可以通过重新组合类间关系实现?

成员函数:              
减少对其他类子程序的间接调用;如  A.B.C.d();
通常应该尽量减少类间合作范围;

为什么要创建类:         
现实世界对象建模             
抽象对象建模  
建立中心控制点    => 中心化与去中心化...             
减低复杂度       
隐藏实现细节       
代码更加易于重用      



避免万能类的创建;         
消除无关紧要的类;         
避免动词命名而构建的类;- 一个类只有行为而没有属性通常不是真正的类;

### 7 高质量的子程序   

看看那些有问题的子程序,子程序的重要性;

为何创建子程序: 

降低复杂度,一旦子程序构建完善,就可以直接调用子程序而忽略细节,子程序的这种抽象能力是复杂项目管理核心,当子程序内部过度复杂时,暗示需要提取新的子程序,子程序这一层中间抽象,对于凝练代码非常有效;

很多看起来似乎简单,而偷懒不构建子程序,在后面由于简单的操作组件业务复杂化,整个逻辑也就开始迅速腐烂了;

子程序的设计: 

最优设计: 每个子程序只做一件事,把一件事做好就足够,这样可以使子程序内部高度内聚,同时也能获取更高的子程序可靠性;

内聚: 
功能内聚(最佳实践)/ 顺序内聚(执行顺序) / 通信内聚(数据通信) / 临时内聚(业务聚合)  

子程序名称:  

避免无意义,模糊亦或是表述不清晰的动词组合:  handle... 等, 子程序本来就是处理事件的.. handle 毫无意义

子程序名称:应该清晰易懂,长度9-15字符数;

名称应该对返回值有所描述;

功能内聚性的子程序通常是针对某对象执行某操作 => 名字可以是 强烈语气动词 + 宾语(对象)

使用对仗词语:  old/new   |  add/remove   

子程序代码长度: 

一般最优为50-150,屏幕一到两屏之间,超过200行的代码可读性方面容易出现问题;

子程序参数控制:  

子程序之间参数通信问题是最常见的内部接口问题;   

参数定义顺序:  按照输入/ 修改 / 输出参数有序定义;  

类似函数使用了类似参数,应让类似参数排列顺序一致;     

传入的参数要被使用,删除未被使用的参数;   

传入的参数通常不应该被作为工作变量被修改,如不恰当的储存临时工作结果,临时结果引入临时变量,澄清入参在子程序中的角色成分;     

依照之前说明过的类数据成员应该在 7+/-2,同样依照人类的零散记忆能力有限,参数也应该控制在7个以内;如果子程序之间互相调用时总是各种参数互相传递,很可能是是程序结构出现了问题,模块之间耦合过于紧密;

函数与过程之分:  

函数代表有返回值的子程序,而过程则是没有返回值的子程序: **如果一个子程序的用途是返回其名称所指明的返回值,则应该使用函数,否则应该使用过程**

**这一部分每个章节后的核对表非常有效,应该经常用于自省自检**

### 8 防御式编程  

### 9 伪码

### 32 自说明代码  


### 33 个人性格