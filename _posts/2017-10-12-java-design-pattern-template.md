---
layout: post
title:  Java 设计模式之模版方法模式
category: other
keywords: [improvement,design,java,]
---

正如从实现中提取模版方法,如果没有设计模式,我们通常直接实现了大量的冗余代码,而后在迭代的过程中来进行重构提取,而有了前人留下的宝贵经验,告诉了我们在哪些常见的问题中我们可以使用模版方法来进项快速而高可扩展的项目构建方式,绘制对应的类图指导编程实践,这事实上省去了我们非常多的时间;诚然,重构是无可避免的,但一定程度上可预见范围内的可避免的过早重构还是用更多的事前考量去避免来的更有效率,毕竟时间是宝贵的;


模版方法是典型的从实现中提取共有,获取更多的复用 - 正如所定义的 抽取算法骨架,延迟实现到子类,骨架不关心具体的业务实现,而交给子类负责,其作用就在于可以不改变结构而即可灵活重新定义其具体实现;

这里需要注意的是抽取骨架的程度,抽取过多会带上血肉,导致类结构膨胀,事实上这也是继承的问题只想要一棵树却带来了整个森林;太过精简骨架不能描绘出完整的模型,建模事实上也是失败的;典型的如 Activity 的生命周期函数,就是完整而又合适的;

模版方法常用于定义框架扩展实践方式,如 数据库分层实践后DAO层的增删改查;

模版方法的抽取我们通常使用抽象类而非接口,听起来似乎与 Java 中面向接口编程有些冲突,但如果我们想到抽象类与接口的差别,抽象类是可以带有具体共有实现的,为子类提供共有功能的直接服务,而不用子类重复实现,甚至可以定义好具体的模版方法执行流程,等待子类具体实现;这样的函数通常称为钩子函数;  

> 抽象类: 既要约束子类行为,又要为子类提供公有功能


将模版定义为抽象类,抽取公有,这公有就是整个定义的骨架,也是我们所定义抽取的不变量,同时我们将具体的业务相关实现留白,定义为抽象函数,这就约束了子类的行为;