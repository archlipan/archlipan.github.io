---
layout: post
title:  Java 设计模式之模版方法模式
category: other
keywords: [improvement,design,java,]
---

正如从实现中提取模版方法,如果没有设计模式,我们通常直接实现了大量的冗余代码,而后在迭代的过程中来进行重构提取,而有了前人留下的宝贵经验,告诉了我们在哪些常见的问题中我们可以使用模版方法来进项快速而高可扩展的项目构建方式,绘制对应的类图指导编程实践,这事实上省去了我们非常多的时间;诚然,重构是无可避免的,但一定程度上可预见范围内的可避免的过早重构还是用更多的事前考量去避免来的更有效率,毕竟时间是宝贵的;


模版方法是典型的从实现中提取共有,获取更多的复用 - 正如所定义的 抽取算法骨架,延迟实现到子类,骨架不关心具体的业务实现,而交给子类负责,其作用就在于可以不改变结构而即可灵活重新定义其具体实现;

这里需要注意的是抽取骨架的程度,抽取过多会带上血肉,导致类结构膨胀,事实上这也是继承的问题只想要一棵树却带来了整个森林;太过精简骨架不能描绘出完整的模型,建模事实上也是失败的;典型的如 Activity 的生命周期函数,就是完整而又合适的;

模版方法常用于定义框架扩展实践方式,如 数据库分层实践后DAO层的增删改查;

模版方法的抽取我们通常使用抽象类而非接口,听起来似乎与 Java 中面向接口编程有些冲突,但如果我们想到抽象类与接口的差别,抽象类是可以带有具体共有实现的,为子类提供共有功能的直接服务,而不用子类重复实现,甚至可以定义好具体的模版方法执行流程,等待子类具体实现;这样的函数通常称为钩子函数;  

> 抽象类: 既要约束子类行为,又要为子类提供公有功能


将模版定义为抽象类,抽取公有,这公有就是整个定义的骨架,也是我们所定义抽取的不变量,同时我们将具体的业务相关实现留白,定义为抽象函数,这就约束了子类的行为;


模版方法的核心在于: 

> 固定算法的骨架

至于具体的实现,可以是公有的实现,也可以是子类的实现;

而模版方法的缺点也由于借助抽象类的而导致模版与子类依赖紧密,牵一发而动全身,而不易改动骨架,即骨架的灵活性不足;因而骨架的抽取需要十分慎重,确保其不变性,通常一类骨架解决一类问题

设计模式中 SOLD 的理念处处得到充分体现;


模版方法模式是一种基础常用模式,基于继承思想抽取不变,定义算法亦或是框架骨架;如当我们知道一个算法结构的关键步骤,但对于其步骤的具体实现却可能随着实现不同而不同,也就是与具体环境相关;通过延迟实现到子类,保证架构所定义的正常逻辑结构正常执行,不被破坏;

模版方法模式的类图是简洁的:

抽象类 ->  具体子类   
   