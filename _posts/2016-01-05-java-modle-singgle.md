---
layout: post
title: Java 模式- 单例
category: java
---

### 从模式说起

模式是针对一些特殊问题的公认的合适的实践方法集合，这些特殊问题往往在开发过程中重复多次出现，因为只有总结重复出现的问题的解决方案才有意义咧，一辈子出现一次的问题，方案总结出来了，大家没机会用，也就不会如Gof这样流传开来，所以这些通用的设计模式的理解与实践是有重要意义的；

通过学习模仿设计模式，并总结自己的一套使用规则可以有效的提升自己的视野，便于从更高的角度去看待代码结构；同时设计模式已经开始成为软件开发行业的一些高级交流术语，也是有必要了解的；

模式的学习不是一蹴而就的，模式需要反复学习，反复总结，当然这些都是勉励我自己的，只有知道学习一样东西的意义才会更加有动力去学习；

 
### 单例模式

保证在应用运行时期，在*整个JVM*中，一个类永远只存在一个实例对象，一般用于处理大型重度使用对象，比如读取配置文件的AppConfig类等；

要想一个类只有一个实例，我们当然首先要屏蔽外部实例构造，也就是 将构造函数私有化；


`private Singleton(){} `

利用这样的方式使外部无法创建对象New实例，同时转化思路，只需要内部创建一个对象暴露给外部使用即可达到目的；进一步思考如何只维护一个对象呢？多各类都使用同一个对象，顺理成章的，静态对象就可以印出来了；

关于内部创建实例，又有两种常用模式，一种懒加载模式，一种是直接创建模式；

关于懒加载：

懒加载是很多地方都常用的一种加载模式，用于在对象真正被用到的时候才去加载创建对象实例，当然在对象被使用之前的内存占用就省去了。

private static Singleton instance;
public static Singleton newInstance(){
    
    if(instance == null){
        instance = new Singleton();
    }
    return instance;
}

那么这种传统懒加载模式有什么劣势呢？当然，如果我们仔细分析，可以看出，如果存在多个线程同时 通过 `newInstance()` 获取对象，而对象还没有的情况，若线程A已运行通过 `instance == null ` 准备执行 创建对象而对象还没创建好的时候，线程B 执行 instance 是否为空的检验，我们可以看到这时候检验也为 null ,所以线程B也会创建新对象，这时线程A 线程B 所拥有的对象是不一样的，也就是单例模式失败了，存在两个对象；

这时我们引入 直接创建模式，如果说懒加载 null 校验存在多线程问题，那么是不是我们直接 最开始就创建好，直接获取会比较好呢？

private static Singleton instance = new Singleton();
public static Singleton getInstance(){
    return instance;
} 

诚然这种方式解决了多线程问题，但是我们考虑一种情况，如果这个对象实在程序执行的末尾做清理工作的，而且对象很重，这种模式我们不是在程序运行初始就创建并且伴随程序整个生命周期，无法释放吗？这样实在浪费；


最后我们引入 Double Check 单例模式：


