---
layout: post
title:  2018 读书记录
category: others
keywords: [improvement,life]
---

读书总结: 

读书不是简单的读过,有用的知识需要一步步掌握消化是其有过程的,思考, 阅读,消化,总结缺一不可,当前越来越体会到总结的重要性;

### 适用型阅读指南

核心: 带着问号去有目的性的搜寻知识

##### 高效读书

明确为了什么而读书? 

消遣的读书? 目的性的读书? 获取知识的读书? 

目的性读书需要讲究效果,实用;

读书可以获得知识,但只有行动才能产生效果;

主动意识的力量: 大脑记忆搜寻-> 有意识的寻找记忆的碎片 -> 闭上眼睛回顾身边的某项事物的情况,睁开眼再去观察会更加清晰,就是主动意识的作用;

搜寻自己需要的知识: 28原则; => 只关注对自己重要的信息 => 问自己想从书中得到什么知识,哪一方面,进而带着问题去探索=> 脑中环绕着问题处理时大脑搜寻的效率更高,专注于自己想要的知识,书中的内容仿佛自动浮现出来一样;  

**非常重要的一点: 书本并没有标准的阅读方式,不是从头到尾一字不漏的阅读才叫读了这本书**(个人: 通读对于梳理整体的脉络是有用的)


书中内容无需全部理解: 只要得到了自己想要的就是有收获=> 吸收那些真正重要的 => 技能型读书与 小说型读书有差异,大脑的自动补全能力;  

带着输出目的的阅读更有效;

挑战同时读多本书,训练自己的大脑;


##### 做笔记

利用思维导图做读书笔记=> 突出书中重点,同时记录自己的感想=> 读完一本书应该要有被触动的相关的一些想法

把握书中的整体层次=> 去哪一块找什么? 类似旅游的攻略,去西湖干嘛? 去黄山干嘛? 总不能去植物园找动物看吧--> 书的目录很重要   

用高效的方式去整理书中知识: 思维导图是一种好的方式;  -> 个人比较喜欢纸张 + 笔 + 扫描全能王(电子档),纸张给人一种随心所欲的感觉,更加符合我的思路  

##### 牢记书中内容

要有意识的去抓住书中的知识;   

巩固那些对自己有用的重要知识=> 反复巩固  => 好书应该值得反复阅读   

调动感情去读书 => 带着感情的阅读记忆效果更好,取悦自己的大脑

以能够向他人讲述出来为目的进行阅读,教是最好的学习方式  

适当的使用便利贴很有用,泡脑子...营造满是相关内容的环境,在哪都能看到   

##### 付诸行动 

知识不是读过就可以了,按照书中的方式去进行尝试总能得到一些收获 

将脑袋里面的想法细化,一步步付诸行动,通常阻碍自己的最大障碍就是害怕失败 => 大胆去进行尝试;       

利用书本中的知识指导自己,整理得到的想法,指导自己的生活,并付诸实践

读到了什么? 触动了什么? 设定目标去行动: 

SMART : 

Specific 具体的

Measurable  可预见的 

Achievable  可达到的

Realistic  现实的

Time-bound  有期限的

对于设定的目标在行动过程中,要能明确当前所处的位置:   类似于对于 todo list 的一个整理过程,当前做了什么,进度多少? 还要做多少? 同步目标, 变化是无时不在的多样的    

要思考自己真正的进度? 完成一半应该是怎么样? 应该达到什么样的进度? 想清楚才能量化当前的进度,才能进一步调整后续的行动=> 进而总结评估前一段时间的行动效果   

整理所写的目标=> todo list 对其中重要性最需要做的进行细化: 多问自己问题? 为什么要做? 必要性是什么? 做了是什么效果,什么结果?   => 确定目标进而才能细化目标 => 将目标分步进行;  为了达到什么目标,一天要做什么? 一周要做什么? 一月要做什么? 什么时候是阶段成果?   



### Unix 编程艺术(选读)

#### Part I:

第三章: Unix 哲学与比较  

主要讲述操作系统的顶层设计是如何影响编程风格的上层建筑的构建形态的;如何去理解操作系统设计者的意图? 成本与编程环境的限制对设计的均衡影响;   


因果论辩证能力: 为何 Unix 的生命力如此顽强?反向看待,为何Unix竞争者在时代的进化过程中被淘汰?是什么根本性劣势导致他们被淘汰? ==> 要去思考,要善于去总结

#### Part II : 

本部分为重点核心关注章节,需要反复读,反复理解;  

第四章: 模块性   

> 模块化原则: 

最佳模块大小

> 紧凑性与正交性     

紧凑性与强单一中心? 如何构建紧凑性的设计?围绕解决一个定义明确的问题去组织算法设计;看不清的时候及时重新回到问题上来; 

核心任务形式化,围绕核心-> 不停的去解决为什么要这么做的问题;力求使他人能够阅读系统设计之后不会产生疑惑,为什么要这么做?   


##### 软件的层次

正交性: 系统的任何操作无副作用,每一个动作只改变一件事,而不影响其他; 如,显示器的亮度与对比度的控制互不关联;

正交性的作用与优势;

正交性与重构的关联;



第五章: 文本化: 论协议        

第六章: 透明性   

第十一章: 接口  


### JavaScript Dom 编程艺术 

第三章:  DOM 

Document & Object & Model

网页被浏览器加载转换形成 Document 对象;

Dom 对象代表着浏览器所加载的当前网页,浏览器将渲染所得到的网页模型提供给出来,该 网页Model 通过 Javascript 代码可以读写操作;

Dom 文档对象是一颗树形结构,也是浏览器实际会渲染的内容树;

Object 在浏览器中包含: 开发者自定义对象,Javascript内建对象,浏览器提供的宿主对象(Document/Window)

节点: 

元素节点 & 文本节点 & 属性节点 : 属性节点补充元素节点的具体描述,而文本节点则表示元素节点所包含的内容;

函数: 针对 Document 的 `getElementById` (返回元素节点对象)以及  `getElementByTagName` `getElementByClassName` 返回对象数组;

针对元素节点对象的 setAttribute


**第五章: 最佳实践**     

* 较低的入门水平导致开发水平参差不齐- HTML            的开发就是典型,入门快,增长快,但同时开发质量难以得到保证.       
* 浏览器的向前兼容特性让新技术的迭代背负巨大的历史包袱---- Android 的开发同学此处有心声        
* 技术本不该背负恶名,每一项技术的诞生都有其解决问题的技术背景,但随着时间的发展,技术最终本身又无法再满足新的需求,很多人在新的时代将骂名转移到这一项在当初非常杰出的技术之上                 
* **javascript: 伪协议**, 通过加载一个链接来调用 Javascript 函数.(这类做法在 Android 中非常常用,当用户禁用 Javascript 功能时,浏览器将什么也不发生)       
* 最佳实践之: CSS 与 HTML 分离,结构与样式分离                 
* 性能优化之: 谨慎的操作 DOM 树, DOM 的操作非常重(引入虚拟 DOM 的原因)      



第七章: 动态创建标记 

传统的 Document.write 与 innerHtml;

Document.write 的问题在于 Controller 与 表现层的 View 混合,职责不分离,导致可读性以及扩展性的下降;

H5规范中的 innerHtml属性,属性html 内容全局替换,无法实现插入;

文档碎片: 已存在的元素节点,但该节点并不属于任何一颗 DOM 树的组成部分;

本节主要介绍了一些 DOM 相关的 API, 如何构建元素节点,文档节点,插入节点,在什么位置插入节点子类的 API, 即用即查即可;

Ajax : 异步加载页面内容,在 Ajax 诞生之前,页面刷新时需要重新加载新的页面,即使只有页面内小部分元素变化也需要重新加载整个页面;

Ajax 核心: XMLHTTPRequest 对象.借助该 JS 对象,绕过了之前的网络请求必须由浏览器发出的限制,而实现自行发起请求,同时操作网络返回.

Ajax 数据的请求只能访问与其所在 HTML 处于同一个域之中的数据,如果向其他域请求数据则出现我们通常所说的跨域问题.(这是由于浏览器安全考虑的限制问题)

Ajax 定义流程:  

* 构建 XMLHTTPRequest 对象   
* 发送请求       
* 定义 onreadystatechange 指定函数引用         
* 在 readyState 属性值之中根据请求状态去操作返回数据 (0/1/2/3/4(完成))  

渐进式增强 Ajax 处理:  Ajax 担任浏览器与服务端的中间人角色,对于老式请求进行拦截处理,在不支持 Ajax 的网站上则进行浏览器与服务端的原生直通; 

整体逻辑上的分层架构处理,Ajax 位于常规站点之上的中间层;              


第九章: CSS-DOM  

网页 = 结构层(HTML/XHTML 标记语言)  & 展示层 (CSS) & 行为层(JS&DOM 构建事件响应层)  

常规领域的展示层的 CSS 职责领域与 行为层的领域存在灰色重叠: 某些 CSS 能够改变行为;  

元素节点的 style 属性对象,提取 style 属性设置是一个比较鸡肋的设定,由于外部分离的 css 样式表无法被 style 属性获取显示;

CSS 的中划线连字符表示在 js 中变换为驼峰表示法(无论多少个连字符在 DOM 中一律变换为驼峰表示)  

可以利用赋值操作来操作 style 属性的属性值,属性值通常用双引号包裹;

额外知识: 

CSS 选择器与 CSS 伪类:

> 选择器包含: 元素通用选择器 & 标签选择器 & css Class 选择器 & css id 选择器     


> CSS 伪类 是添加到选择器的关键字，指定要选择的元素的特殊状态。例如，:hover 可被用于在用户将鼠标悬停在按钮上时改变按钮的颜色。

伪类是选择器选择信息的补充;

{% highlight javascript %} 

// addloadevent 
function addLoadEvent(func){  
        var oldonLoad = window.onload;  
        if(typeof window.onload!='function'){  
                window.onload = func;  
        }  
        else{  
            window.onload = function(){  
                oldonload();  
                func();  
            }  
        }  
} 

// onload 函数在 HTML 文档全部加载完毕,DOM结构树构建成功之后执行调用

{% endhighlight %}






### HTML5 与 CSS3 权威指南(上)



### HTML5 与 CSS3 权威指南(下)



### HeadFirst 软件开发





