---
layout: post
title:  重构与模式精读
category: others
keywords: [improvement,java]
---

**重构与模式(Refactoring to Patterns)**

简化与泛化两章占用了本书一半的篇幅,是重中之重,需要时时温故而知新,多思考,多总结,多结合实际情况去体会作者的思考过程;

**实际情况中通过分析,期望以重构为手段实现各类模式的优雅使用.在我看来,模式的本质是章法,有了章法则心中不乱,手上不慌,借助章法但又不能局限于章法,有了章法可以站在前人的肩膀上看的更远,局限于章法却又往往容易脱离实际落个生搬硬套的俗套**

实际情况中,究竟是需要实现模式? 还是趋近于模式就值得分析情况了,但无论如何重构的一些手段与情况确实是非常重要的,如何去拓展功能?拓展他人代码?从旧的代码中添加新的业务逻辑而又尽可能的保留原有结构的完整性,尽可能的减慢代码的腐朽程度,甚至让代码重新焕发生机.

### 简化

#### 组合方法  

提炼函数:那个函数包含哪些代码?命名是否能够真实表达代码逻辑?意图要被真实而清晰表达

提炼函数带来的性能问题? 是否真实的带来性能问题需要 profile 确认 - 原则等到需要优化时再进行优化;

统一逻辑层次,更抽象更清晰:一个方法分解为一组行为时,需要保证行为在细节的相似层面.行为的层面?高级别与低级别,如 打开文件/关闭文件;

如: guard clause : if(true) return 提前声明出口

组合方法借助抽取方法的手段是简单,但直接且有效的重构途径

### 策略简化

大多数时候复杂的业务场景都伴随着复杂的 if/else 语句,正如有人透漏百度无人驾驶超过10万的 if/else, 或许带着些许夸张,但对于驾驶的复杂程度来说当然也是可信的;

> 复杂的条件逻辑是最常导致复杂度上升的地方之一

事实上,随着业务的推进,算法的逻辑总是在增长,这类条件逻辑更是迅速膨胀,并最终成为业务遗留代码;

条件通常决定算法的实际变体类型,而其精简方案通常是分解条件以及精简逻辑结合组合方法;而在实际应用中又有 组合与继承的实现方式,继承则将算法在子类实现,而组合则利用一个个特殊类进行业务处理;通常继承与多态总是相伴,多态给类的实现带来了充分的灵活性与扩展性,而又通过继承保留了父类的约束;而借助组合的方式则利用策略的一个实现,并在算法的实现过程中将实际算法实现委托给具体策略执行,并将上下文环境注入到策略中,以便策略利用外部环境选择具体策略

注入上下文环境是策略实现的关键:究竟是将环境对象注入以便直接获取到环境的所有属性与方法,还是将环境对象的属性一一借助 setter 注入到策略是需要考量的;


### 核心装饰

装饰为核心功能赋予了良好的后期扩展性,保护了类职责的清晰,逻辑的清晰;事实上,在通常的业务中,一旦涉及到核心功能的扩展以及更改,如果简单的在旧类中增添新的代码,新的字段,新的逻辑,新的职责加入后将导致原有类的复杂度几何倍增,类的意义开始不明,职责界限开始混杂,更麻烦的是这些新加入的逻辑只是在某些条件下才会触发;

而装饰模式,则很好的解决了这一问题,装饰的功能逻辑独立存在,在特定的逻辑需要时,则通过装饰核心类,通过核心类的包装对象完成对应的业务逻辑,当脱去外衣,核心类还是本来的面貌;  

>  透明的包装

装饰应该实现所有被包装类中被暴露的方法,从而达到被包类无感知自身被包装,而如果被包装类的暴露方法过多,将导致装饰者需要实现过多冗余函数才能达到透明包装的目的,因而核心类的暴露应该是精简的;

包装事实上是将一个类中的复杂逻辑代码分离到了各个装饰器中,当然这就提升了代码理解的复杂度,毕竟无论如何代码被分散了,逻辑的分散还带来了调试的复杂度提升问题,这都是需要考量的问题.  

装饰的变种--代理,事实上二者的实现非常相近,但实现的意图则大不相同,代理意在保护目标对象不被破坏,屏蔽对象被外部直接真实访问;而装饰则是行为的添加与扩展;


> 重构中装饰模式与策略模式的竞争关系:去除特殊情况或选择性行为相关联的条件逻辑,且通过将行为搬移的方式达到去除关联性的目的;而具体情况下究竟使用何种方式则需要因地制宜,实际情况实际分析;


### 泛化

从特殊到通用




